# Double x and y
plot(2*x,2*y)
par(mfrow=c(1,1))
cov(x,y)
cov(2*x,2*y)
# Make up some random values
x <- rnorm(20,0,1)
y <- 2*x+rnorm(20,0,0.5)
# Scatter plot
plot(x,y)
# Check independence of the dependent variable
runs.test(x)
runs.test(y)
# Check outliers
grubbs.test(x)
grubbs.test(y)
grubbs.test(y)
# Check normality
# Sample size < 30, use the Shapiro-Wilk test
shapiro.test(x)
shapiro.test(y)
# Check normality
# Sample size < 30, use the Shapiro-Wilk test
shapiro.test(x)
shapiro.test(y)
cor.test(x, y, method="pearson", alternative="two.sided", conf.level=0.95)
# Check outliers
grubbs.test(x)
grubbs.test(y)
cor.test(x, y, method="pearson", alternative="two.sided", conf.level=0.95)
# Compute Pearson Correlation Coefficient
cor(x, y)
# Make up two samples
x <- c(0.1, -1.6, -2.3,  0.1,  0.1,  0.5, -0.3, -0.3, 1.4,  0.3)
y <- 2*x+c(-0.4, -0.4, -0.4,  0.2, -1.6,  0.2,  0.2,  0.6,  0.2, 1.1)
# Add one outlier
x <- c(x, -20)
y <- c(y, 30)
# Compute Pearson Correlation Coefficient
cor(x, y)
# Uncomment the following lines to remove the outlier
x <- x[- 11]
y <- y[- 11]
# Compute Pearson Correlation Coefficient without the outlier
cor(x, y)
plot(x,y)
# Make up two samples
x <- c(0.1, -1.6, -2.3,  0.1,  0.1,  0.5, -0.3, -0.3, 1.4,  0.3)
y <- 2*x+c(-0.4, -0.4, -0.4,  0.2, -1.6,  0.2,  0.2,  0.6,  0.2, 1.1)
# Add one outlier
x <- c(x, -20)
y <- c(y, 30)
plot(x,y)
# Make up samples
x1 <- c(0.1, -1.6, -2.3,  0.1,  0.1,  0.5, -0.3, -0.3, 1.4,  0.3)
y1 <- 2*x1+c(-0.4, -0.4, -0.4,  0.2, -1.6,  0.2,  0.2,  0.6,  0.2, 1.1)
x2 <- x1-5.0
y2 <- -1.0*y1
x <- c(x1,x2)
y <- c(y1,y2)
# Compute the Pearson correlation coefficient between x1 and y1.
cor(x1, y1)
# Compute the Pearson correlation coefficient between x2 and y2.
cor(x2, y2)
# Compute the Pearson correlation coefficient between x and y
cor(x, y)
# Scatter plot, check linearity
plot(TOC, UV)
TOC <- c(1.59, 1.79, 1.00, 0.45, 3.84, 2.30, 1.00,
3.20, 0.80, 2.20, 3.20, 2.10)
UV  <- c(0.144, 0.152, 0.113, 0.025, 0.227, 0.149,
0.014, 0.158, 0.042, 0.154, 0.173, 0.095)
# Scatter plot, check linearity
plot(TOC, UV)
# Check independence of the dependent variable
runs.test(TOC)
runs.test(UV)
# Check normality
# Sample size < 30, use the Shapiro-Wilk test
shapiro.test(TOC)
shapiro.test(UV)
# Check outliers
grubbs.test(TOC)
grubbs.test(UV)
cor.test(TOC, UV, method="pearson",
alternative="two.sided", conf.level=0.95)
# TOC SHOULD be positively correlated with UV
# because of Lamber-Beers Law
cor.test(TOC, UV, method="pearson",
alternative="greater", conf.level=0.95)
# Two-sided p-value
cor.test(TOC, UV, method="pearson",
alternative="two.sided", conf.level=0.95)
# Make up samples
x1 <- c(0.1, -1.6, -2.3,  0.1,  0.1,  0.5, -0.3, -0.3, 1.4,  0.3)
y1 <- 2*x1+c(-0.4, -0.4, -0.4,  0.2, -1.6,  0.2,  0.2,  0.6,  0.2, 1.1)
x2 <- x1-5.0
y2 <- -1.0*y1
x <- c(x1,x2)
y <- c(y1,y2)
plot(x1,y1,col="red")
points(x2,y2,col="green")
plot(x,y,col="black")
points(x1,y1,col="red")
points(x2,y2,col="green")
plot(x,y,col="black")
points(x1,y1,col="red",cex=2)
points(x2,y2,col="blue",cex=2)
plot(x,y,col="black")
plot(x,y,col="black")
points(x1,y1,col="red",cex=2)
points(x2,y2,col="blue",cex=2)
# Compute the Pearson correlation coefficient between x1 and y1.
cor(x1, y1)
# Compute the Pearson correlation coefficient between x2 and y2.
cor(x2, y2)
# Compute the Pearson correlation coefficient between x and y
cor(x, y)
# Scatter plot, check linearity
plot(TOC, UV)
# Two-sided p-value
cor.test(TOC, UV, method="pearson",
alternative="two.sided", conf.level=0.95)
# TOC SHOULD be positively correlated with UV
# because of Lamber-Beers Law
cor.test(TOC, UV, method="pearson",
alternative="greater", conf.level=0.95)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Plot the scatter plot
plot(Soil_conc,Uptaken_amount)
# Compute the Pearson correlation coefficient
r              <- cor(Soil_conc, Uptaken_amount)
print(r)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Plot the scatter plot
plot(Soil_conc,Uptaken_amount)
# Compute the Pearson correlation coefficient
r              <- cor(Soil_conc, Uptaken_amount)
print(r)
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# Check SST = SSR + SSE
SST - SSR - SSE
# Compute R2
R2             <- SSR/SST
# Check R2 = r2
print(R2)
print(r^2)
# Check R2 = r2
print(R2-r^2)
# Fit a simple linear regression model between
# dependent variable (Uptaken_amount) and
# independent variable (Soil_conc)
reg            <- lm( Uptaken_amount ~ Soil_conc )
# Print details of the linear model
summary(reg)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Plot the scatter plot
plot(Soil_conc,Uptaken_amount)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Plot the scatter plot
plot(Soil_conc,Uptaken_amount)
# Compute the Pearson correlation coefficient
r              <- cor(Soil_conc, Uptaken_amount)
print(r)
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# Check SST = SSR + SSE
SST - SSR - SSE
# Compute R2
R2             <- SSR/SST
# Check R2 = r2
print(R2)
# Fit a simple linear regression model between
# dependent variable (Uptaken_amount) and
# independent variable (Soil_conc)
reg            <- lm( Uptaken_amount ~ Soil_conc )
# Print details of the linear model
summary(reg)
# Check SST = SSR + SSE
SST - SSR - SSE
# Fit a simple linear regression model
reg            <- lm( UV ~ TOC )
# Print details of the linear model
summary(reg)
library(ggplot2)
library(randtests)
library(outliers)
library(ggplot2)
library(randtests)
library(outliers)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Degrees of freedom
# Model, simple linear regression–the slope and intercept
df_regression  <- 2 - 1 # 2 parameters
# Error
df_error       <- length(Soil_conc) - 2
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# MSE
MSE            <- SSE/df_error
# Get SE of residual
print(sqrt(MSE))
library(ggplot2)
library(randtests)
library(outliers)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Degrees of freedom
# Model, simple linear regression–the slope and intercept
df_regression  <- 2 - 1 # 2 parameters
# Error
df_error       <- length(Soil_conc) - 2
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# MSE
MSE            <- SSE/df_error
# Get SE of residual
print(sqrt(MSE))
# SE of beta1_hat
SE_beta1_hat   <- sqrt(MSE/sum((Soil_conc-mean(Soil_conc))^2))
# Get t statistic
t_beta1        <- Beta1_hat / SE_beta1_hat
# Find the two-side p-value
# The pt function gives the Cumulative Distribution Function (CDF)
# of the Student's t distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here |t|).
P_value        <- (1-pt(abs(t_beta1), df=df_error))*2
print(P_value)
library(ggplot2)
library(randtests)
library(outliers)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Degrees of freedom
# Model, simple linear regression–the slope and intercept
df_regression  <- 2 - 1 # 2 parameters
# Error
df_error       <- length(Soil_conc) - 2
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# MSE
MSE            <- SSE/df_error
# Get SE of residual
print(sqrt(MSE))
# SE of beta1_hat
SE_beta1_hat   <- sqrt(MSE/sum((Soil_conc-mean(Soil_conc))^2))
# Get t statistic
t_beta1        <- Beta1_hat / SE_beta1_hat
# Find the two-side p-value
# The pt function gives the Cumulative Distribution Function (CDF)
# of the Student's t distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here |t|).
P_value        <- (1-pt(abs(t_beta1), df=df_error))*2
print(P_value)
# Get F-statistic
MSR            <- SSR/df_regression
F_ratio        <- MSR/MSE
# Find the p-value
# The pf() function gives the Cumulative Distribution Function (CDF)
# of the F distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here F_ratio).
# Here we that 1-pf to get the probability that the
# variable takes a value higher than the threshold (F_ratio).
P_value        <- 1 - pf(F_ratio, df1=df_regression, df2=df_error)
print(P_value)
library(ggplot2)
library(randtests)
library(outliers)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Degrees of freedom
# Model, simple linear regression–the slope and intercept
df_regression  <- 2 - 1 # 2 parameters
# Error
df_error       <- length(Soil_conc) - 2
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# MSE
MSE            <- SSE/df_error
# Get SE of residual
print(sqrt(MSE))
# SE of beta1_hat
SE_beta1_hat   <- sqrt(MSE/sum((Soil_conc-mean(Soil_conc))^2))
# Get t statistic
t_beta1        <- Beta1_hat / SE_beta1_hat
# Find the two-side p-value
# The pt function gives the Cumulative Distribution Function (CDF)
# of the Student's t distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here |t|).
P_value        <- (1-pt(abs(t_beta1), df=df_error))*2
print(P_value)
# Get F-statistic
MSR            <- SSR/df_regression
F_ratio        <- MSR/MSE
# Find the p-value
# The pf() function gives the Cumulative Distribution Function (CDF)
# of the F distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here F_ratio).
# Here we that 1-pf to get the probability that the
# variable takes a value higher than the threshold (F_ratio).
P_value        <- 1 - pf(F_ratio, df1=df_regression, df2=df_error)
print(P_value)
# R-squared
R2             <- SSR/SST
print(R2)
library(ggplot2)
library(randtests)
library(outliers)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Degrees of freedom
# Model, simple linear regression–the slope and intercept
df_regression  <- 2 - 1 # 2 parameters
# Error
df_error       <- length(Soil_conc) - 2
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# MSE
MSE            <- SSE/df_error
# Get SE of residual
print(sqrt(MSE))
# SE of beta1_hat
SE_beta1_hat   <- sqrt(MSE/sum((Soil_conc-mean(Soil_conc))^2))
# Get t statistic
t_beta1        <- Beta1_hat / SE_beta1_hat
# Find the two-side p-value
# The pt function gives the Cumulative Distribution Function (CDF)
# of the Student's t distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here |t|).
P_value        <- (1-pt(abs(t_beta1), df=df_error))*2
print(P_value)
# Get F-statistic
MSR            <- SSR/df_regression
F_ratio        <- MSR/MSE
# Find the p-value
# The pf() function gives the Cumulative Distribution Function (CDF)
# of the F distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here F_ratio).
# Here we that 1-pf to get the probability that the
# variable takes a value higher than the threshold (F_ratio).
P_value        <- 1 - pf(F_ratio, df1=df_regression, df2=df_error)
print(P_value)
# R-squared
R2             <- SSR/SST
print(R2)
# Adjusted R-squared
n              <- length(Soil_conc)
k              <- 1 # only beta1 counts
R2_adj         <- 1 - (1-R2)*(n-1)/(n-k-1)
print(R2_adj)
library(ggplot2)
library(randtests)
library(outliers)
# Observations
Soil_conc      <- c(10, 50, 20, 30, 80, 60, 70, 40)
Uptaken_amount <- c(0.18, 1.05, 0.50, 0.61, 1.58, 1.10, 1.36, 0.77)
# Degrees of freedom
# Model, simple linear regression–the slope and intercept
df_regression  <- 2 - 1 # 2 parameters
# Error
df_error       <- length(Soil_conc) - 2
# Get estimator of beta1 and beta0 manually
Beta1_hat      <- cov(Soil_conc, Uptaken_amount)/sd(Soil_conc)^2
Beta0_hat      <- mean(Uptaken_amount) - Beta1_hat*mean(Soil_conc)
# Predictions based on the linear model
Prediction     <- Beta0_hat + Soil_conc*Beta1_hat
# Variance analysis
SST            <- sum( (Uptaken_amount - mean(Uptaken_amount))^2 )
SSR            <- sum( (Prediction - mean(Uptaken_amount))^2   )
SSE            <- sum( (Uptaken_amount- Prediction)^2 )
# MSE
MSE            <- SSE/df_error
# Get SE of residual
print(sqrt(MSE))
# SE of beta1_hat
SE_beta1_hat   <- sqrt(MSE/sum((Soil_conc-mean(Soil_conc))^2))
# Get t statistic
t_beta1        <- Beta1_hat / SE_beta1_hat
# Find the two-side p-value
# The pt function gives the Cumulative Distribution Function (CDF)
# of the Student's t distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here |t|).
P_value        <- (1-pt(abs(t_beta1), df=df_error))*2
print(P_value)
# Get F-statistic
MSR            <- SSR/df_regression
F_ratio        <- MSR/MSE
# Find the p-value
# The pf() function gives the Cumulative Distribution Function (CDF)
# of the F distribution in R, which is the probability that
# the variable takes a value lower or equal to a threshold (here F_ratio).
# Here we that 1-pf to get the probability that the
# variable takes a value higher than the threshold (F_ratio).
P_value        <- 1 - pf(F_ratio, df1=df_regression, df2=df_error)
print(P_value)
# R-squared
R2             <- SSR/SST
print(R2)
# Adjusted R-squared
n              <- length(Soil_conc)
k              <- 1 # only beta1 counts
R2_adj         <- 1 - (1-R2)*(n-1)/(n-k-1)
print(R2_adj)
# Fit a simple linear regression model between
# dependent variable (Uptaken_amount) and
# independent variable (Soil_conc)
reg            <- lm( Uptaken_amount ~ Soil_conc )
# Print details of the linear model
summary(reg)
# Print the ANOVA table
anova(reg)
# Make confidence band
predict(reg, interval="confidence", level=0.95)
# Make Prediction band
predict(reg, interval="prediction", level=0.95)
# Make data frame
Pesticide_data  <- data.frame(Soil_conc,Uptaken_amount)
# Build the model
reg             <- lm(Uptaken_amount ~ Soil_conc, data=Pesticide_data)
# Make predictions for individual responses
Pred_band       <- predict(reg, interval="prediction", level=0.95)
# Make predictions for individual responses
Pred_band       <- predict(reg, interval="prediction", level=0.95)
# Update data frame
Pesticide_data2 <- cbind(Pesticide_data, Pred_band)
# Plot
ggplot(Pesticide_data2, aes(Soil_conc, Uptaken_amount))+
geom_point() +
geom_line(aes(y=lwr), color = "red", linetype = "dashed")+
geom_line(aes(y=upr), color = "red", linetype = "dashed")+
geom_smooth(method=lm, se=TRUE)
# Check independence of the dependent variable (Y)
runs.test(Pesticide_data$Uptaken_amount)
# Scatter plot
# Do you see a linear trend
plot(Pesticide_data$Uptaken_amount, Pesticide_data$Soil_conc)
# Check potential outliers
boxplot(Pesticide_data$Uptaken_amount)
grubbs.test(Pesticide_data$Uptaken_amount)
# Build the model
reg             <- lm(Uptaken_amount ~ Soil_conc, data=Pesticide_data)
summary(reg)
par(mfrow = c(2, 2))
plot(reg)
par(mfrow = c(1, 1))
setwd("C://ese335")
rmarkdown::render_site()
rmarkdown::render_site()
